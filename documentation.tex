\documentclass{report}[12pt]
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{cite}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{float}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{siunitx}
\usepackage{enumitem}
\usepackage{textcomp}
\usepackage{setspace}
\usepackage{subcaption}


\usepackage{color}   
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, 
    linktoc=all,     
    linkcolor=blue,  
    allcolors=blue
}

\author{Anurag Gupta (183230006) \\ Ponala Venkata Eswara Srisai
(183230008)\\ Sudhakar Kumar (183236001)\\ Kishan Chouhan (183230015)}
\title{Systems and Control Engineering Laboratory (SC 626) \\ Kilobotics}

\begin{document}
\maketitle
\tableofcontents
\thispagestyle{empty}
\mbox{}
%\input{tex/archive.tex}

\chapter{Efficient star-planet orbiting using a finite state machine}
\section{Discussion}
\begin{itemize}
    \item Motor was turned on for 40ms.
    \item Spinup motor was not used as it creates chaos.
    \item Revolution time around 6 minutes.
    \item Only left, right motion was used for orbiting.
    \item Algorithm can be improved using soft delay instead of hard delay.
    \item Algorithm for escaping $too\_close$ distance worked and then stopped working suddenly.
    \item Use $max\_distance-min\_distance>some\_threshold$ to obtain orientation away from obstacle. This is more robust than checking for transition from increasing to decreasing distance.
    \item Draw flowchart for the algorithm.
    \item Motor spinup is to be used.
    \item Too close escape worked. Oscillations due to threshold on difference to check from minimum distance ($threshold\_rotate = $). New robust algorithm was used. In worst case, it will require one complete rotation.
    \item When only one distance was used, it created instability in tracking the desired orbit because planet makes only one reception and makes it decision entirely on that estimated distance.
    \item Minimum of four communication distance was used. When planet is in communication range of both the robots, it makes decision quickly but when it is in communication range of only one robot, it takes longer as it takes more time to receive 4 communication from a single star than 4 communication from two star. (Motor delay = 200, No. of communications = 4, Time = 23 minutes, 9:30 p.m.).
    \item (Motor delay = 500, No. of communications = 2, Time = 5 minutes, 9:30 p.m.). This time there is possibility of receiving communication from same star twice but that is small over successive trials.
    \item Too close escape. (Motor delay = 500, threshold = 14, radius = 65, Time = 2 minutes, 10:23 p.m.)
    \item Orbiting three stars (Time = 6 minutes, Communication = 4, Motor delay = 500).
    \item Assign different data to stars.
    \item Use float to store distance.
\end{itemize}
\section{Flowchart}
Flowcharts ADD HERE.

\section{Code}
\lstset{
    language=C,
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,       
    tabsize=2,           
    captionpos=b,                   
    breaklines=true,               
    breakatwhitespace=true,       
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{ForestGreen}\ttfamily,
    %identifierstyle=\color{Mulberry},
    morecomment=[l][\color{BrickRed}]{\#},
    numberstyle=\color{gray}
}

\lstinputlisting{code/orbit_planet_with_escape.c}

\section{Demonstration}
Figure \ref{fig:efficient_star_planet_orbiting} provides link to the demo for orbiting of planet around the star given star starts near the desired distance.
\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=3in]{images/efficient_orbiting}}
    \caption{\href{https://youtu.be/LRgOzhAJI1k}{Efficient star-planet orbiting}}
    \label{fig:efficient_star_planet_orbiting}
\end{figure}

%Figure \ref{fig:escape_too_close} provides link to the demo of algorithm for planet to go away from too close region.
%\begin{figure}[H]
    %\centering
    %\fbox{\includegraphics[width=3in]{images/too_close}}
    %\caption{\href{https://photos.app.goo.gl/no8unyVke2eyDXXT9}{Escaping too close region of star by planet (Planet: Kilobot with red LED)}}
    %\label{fig:escape_too_close}
%\end{figure}

Figure \ref{fig:orbit_after_escape} provides link to the demo of algorithm for planet to go away from too close region using a robust algorithm followed by orbiting.
\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=3in]{images/orbit_after_escape}}
    \caption{\href{https://youtu.be/X6dGCLT0ho8}{Escaping too close region of star by planet followed by orbiting}}
    \label{fig:orbit_after_escape}
\end{figure}

Figure \ref{fig:orbit_two_star_comm1} provides link to the demo of algorithm for planet to orbit around two stars. Only single communication was used to identify minimum distance, leading to instability which can be attributed to CSMA/CD \cite{WEBOPEDIA-csma-cd} communication protocol followed by Kilobots.
\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=3in]{images/orbit_two_stars_comm_1}}
    \caption{\href{https://youtu.be/mhW04WvGKuQ}{Orbiting of planet around two stars using single communication to estimate minimum distance leads to instability}}
    \label{fig:orbit_two_star_comm1}
\end{figure}

Figure \ref{fig:orbit_two_star} provides link to the demo of algorithm for planet to orbit around two stars where planet uses two communications to make a descision.
\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=3in]{images/orbit_two_stars}}
    \caption{\href{https://youtu.be/EKvty2OxXxM}{Orbiting of planet around two stars using two communications to estimate minimum distance}}
    \label{fig:orbit_two_star}
\end{figure}

Figure \ref{fig:orbit_three_stars} provides link to the demo of algorithm for planet to orbit around three stars forming a triangle. Planet uses four communications to make a descision.
\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=3in]{images/orbiting_three_stars}}
    \caption{\href{https://youtu.be/5aZm0Os9BPc}{Orbiting of planet around three stars using four communications to estimate minimum distance}}
    \label{fig:orbit_three_stars}
\end{figure}

\chapter{Shape formation}
In this chapter, we will discuss an algorithm motivated by the work \cite{MR-AC-RN:2014} of SSL lab, Harvard University, for shape formation. Rather than implementing the entire algorithm, we will only consider a portion of it, assuming that the next robot to be placed is available near origin.
\section{Framework}
\begin{itemize}
        \item Three robots (guides) are used as reference for axis orientation.
        \item A robot (builder) participating in shape formation starts near the left of origin.
        \item In its effort to reach the desired location, builder orbits around the partial shape using the algorithm presented in last chapter.
        \item The builder stops orbiting when it reaches the desired location.
        \item Builder becomes a guide, thereby, helping the next builder.
\end{itemize}
To participate in shape formation, builders need to decide upon what global shape to form. This is achieved by sharing a shape matrix encapsulating the desired shape as an array of 5-tuple. The 5-tuple contains the following information necessary for establishing builders at desired location:
\begin{align}
\left(
\begin{matrix}
    Index & Neighbour_1 & Desired\ distance_1 & Neighbour_2 & Desired\ distance_2
\end{matrix}
\right)
\end{align}
For forming a linear shape of width 2, the shape matrix would look like
\begin{align}
\label{eq:shape_matrix_linear}
\begin{bmatrix}
    3 & 1 & 1 & 2 & 1\\
    4 & 2 & 1 & 3 & \sqrt{2}\\
    5 & 3 & 1 & 4 & 1\\
    \cdots & \cdots & \cdots & \cdots & \cdots
\end{bmatrix}
\end{align}
It is important to note that we require the shape to ensure two neighbours for each node or else builder would fail to localize correctly.
\section{Flowchart}
Figure \ref{fig:fc_shape_form} explains the algorithm for shape formation. Our algorithm differs from \cite{MR-AC-RN:2014} in its implementation of shape matrix, and localization to be discussed later in next section.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{images/shape_formation}
    \caption{Flowchart for shape formation algorithm}
    \label{fig:fc_shape_form}
\end{figure}

\section{Discussion}
Figure \ref{fig:shape_formation_process_1} and \ref{fig:shape_formation_process_2} helps in visualizing the shape formation process for shape matrix \eqref{eq:shape_matrix_linear}, which corresponds to a line of width 2. Black circles indicate guide robots which continuously transmit their $Index$, whereas grey circles indicate the oncoming builder robot. Shaded circle corresponds to a builder transforming into a guide. A builder is always in listener mode, whereas a guide is always in speaker mode of communication. Dotted lines trace the path of builder.

When first builder initialized with $Index=3$ starts its journey, as shown in Figure \ref{fig:shape_formation_process_1}, it never faces a situation which requires $Index$ update and hence, it ultimately reaches the desired location corresponding to $Index$ 3 and transforms into a guide robot. 
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{"images/shape_formation_process_1"}
    \caption{First builder taking its position}
    \label{fig:shape_formation_process_1}
\end{figure}
When second builder arrives with $Index=3$, as shown in Figure \ref{fig:shape_formation_process_2}, it continues on its journey to occupy the desired location coresponding to $Index$ 3, but when it comes in the communication range of new guide with $Index=3$, it realizes that it needs to update its $Index$ to 4. Following which, it travels to the desired location corresponding to $Index=4$ and transforms into a guide.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{"images/shape_formation_process_2"}
    \caption{Second builder taking its position}
    \label{fig:shape_formation_process_2}
\end{figure}

\section{Code}
\lstset{
    language=C,
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,       
    tabsize=2,           
    captionpos=b,                   
    breaklines=true,               
    breakatwhitespace=true,       
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{ForestGreen}\ttfamily,
    %identifierstyle=\color{Mulberry},
    morecomment=[l][\color{BrickRed}]{\#},
    numberstyle=\color{gray}
}

\lstinputlisting{code/shape_formation.c}

\section{Demonstration}
Figure \ref{fig:shape_formation_demo} provides the link to video of shape formation in action. Shape matrix \eqref{eq:shape_matrix_linear} was fed to each builder robots to form a rectangle  breadth=2 and length=3. $EPSILON\_MARGIN$ and $MOTOR\_ON\_DURATION$ play an essential role in determining the stability and accuracy of shape formation. For large $MOTOR\_ON\_DURATION$, it is likely for builder to go beyond its desired location and continue orbiting whereas for larger $EPSILON\_MARGIN$, we get distortion in shape. Moreover, we can not choose very small $EPSILON\_MARGIN$ due to error in measurements. One way to improve accuracy of shape is by adaptively decreasing the $MOTOR\_ON\_DURATION$ of builder when it comes in the comunication range of desired neighbours.
\begin{figure}[H]
    \centering
    \fbox{\includegraphics[width=5in]{images/shape_formation_demo}}
    \caption{\href{https://youtu.be/SoDq9GQvNAE}{Shape formation by kilobots (Shape: Rectangle of breadth=2 and length=3)}}
    \label{fig:shape_formation_demo}
\end{figure}

\chapter{Conclusion}
During our lab work on Kilobotics, we developed essential building blocks for implementation of shape formation algorithm. In the process, we tested algorithms for efficient orbiting, algorithm for escaping an obstacle, algorithm for orbiting multiple stars, and lastly, we also implemented a rudimentary shape formation algorithm for Kilobots. There's a lot which needs to be achieved in terms of robustness in performance and integration of individual building blocks. Further, one may also pursue development f macros to generate shape matrix from a bitmap image.
\section{Acknowledgement}
We would like to thank Tejdeep Reddy for his teaching assistance and lab staffs for maintaining a healthy number of working robots. Moreover, we would like to thank Prof. Leena Vachhani for her coursework on Automation and Feedback which motivated us to approach the problem using finite state machine.
\bibliography{anurag}{}
\bibliographystyle{ieeetr}
\end{document}
